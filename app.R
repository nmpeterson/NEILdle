#install.packages(c("shiny", "htmltools", tidyverse", "sf"))
#devtools::install_github('cmap-repos/cmapgeo')
library(shiny)
library(htmltools)
library(tidyverse)
library(sf)
library(cmapgeo)

## Load dataset generated by data-raw/geolist.R
load("data/all_geos.rda")
load("data/geo_distances.rda")

## Set global vars
THE_NAME <- "NEILdle"
THE_URL <- "https://bit.ly/NEILdle"

# Still TO-DO:
# - if solved, don't share number of letters in the guess/solution emoji
# - add date to endgame-content
# - clean up layout, fonts, etc.
# - use a seed based on date for a unique daily puzzle (just uncomment)

ui <- fluidPage(
  theme = bslib::bs_theme(version = 4, bootswatch = "litera"),
  title = THE_NAME,
  tags$style(HTML("
    .container-fluid {
        text-align: center;
        height: calc(100vh - 30px);
        display: grid;
        grid-template-rows: 1fr auto;
    }
    .guesses {
        text-align: left;
        overflow-y: auto;
        height: 100%;
    }
    .guesses.finished {
        overflow-y: visible;
    }
    .guesses .word {
        margin: 5px;
    }
    .guesses .word > .letter {
        display: inline-block;
        width: 30px;
        height: 30px;
        text-align: center;
        vertical-align: middle;
        border-radius: 3px;
        line-height: 30px;
        font-size: 20px;
        font-weight: bold;
        vertical-align: middle;
        user-select: none;
        color: white;
        font-family: 'Clear Sans', 'Helvetica Neue', Arial, sans-serif;
    }
    .guesses .word > .correct {
        background-color: #6dae4f;
    }
    .guesses .word > .in-word {
        background-color: #d3b42b;
    }
    .guesses .word > .not-in-word {
        background-color: #2d4147;
    }
    .guesses .word > .guess {
        color: black;
        background-color: white;
        border: 1px solid black;
    }
    #invalid-guess,
    .loser {
        color: #ca3428;
        font-weight: bold;
    }
    #cds_link {
        font-weight: bold;
    }
    #keyboard .keyboard {
        height: 240px;
        user-select: none;
    }
    #keyboard .keyboard .keyboard-row {
        margin: 3px;
    }
    #keyboard .keyboard .keyboard-row .key {
        display: inline-block;
        padding: 0;
        width: 30px;
        height: 50px;
        text-align: center;
        vertical-align: middle;
        border-radius: 3px;
        line-height: 50px;
        font-size: 18px;
        font-weight: bold;
        vertical-align: middle;
        color: black;
        font-family: 'Clear Sans', 'Helvetica Neue', Arial, sans-serif;
        background-color: #e2e7ea;
        touch-action: none;
    }
    #keyboard .keyboard .keyboard-row .key:focus {
        outline: none;
    }
    #keyboard .keyboard .keyboard-row .key.wide-key {
        font-size: 15px;
        width: 100px;
    }
    #keyboard .keyboard .keyboard-row .key.correct {
        background-color: #6dae4f;
        color: white;
    }
    #keyboard .keyboard .keyboard-row .key.in-word {
        background-color: #d3b42b;
        color: white;
    }
    #keyboard .keyboard .keyboard-row .key.not-in-word {
        background-color: #2d4147;
        color: white;
    }
    .endgame-content {
        font-family: Helvetica, Arial, sans-serif;
        display: inline-block;
        line-height: 1.4;
        letter-spacing: .2em;
        text-align: left;
        margin: 20px 8px;
        width: fit-content;
        padding: 20px;
        border-radius: 5px;
        box-shadow: 4px 4px 19px rgb(0 0 0 / 17%);
    }
  ")),
  fluidRow(
    div(class = "title-and-map col-md",
      h1(THE_NAME),
      plotOutput("geo_map")
    )
  ),
  fluidRow(
    div(class = "guesses col-md",
      uiOutput("previous_guesses"),
      uiOutput("current_guess")
    )
  ),
  fluidRow(
    div(class = "endgame col-md",
      uiOutput("loser_message"),
      uiOutput("cds_link"),
      #plotOutput("final_map"),
      uiOutput("endgame")
    ),
  ),
  # fluidRow(
  #   div(class = "new-game col-md",
  #     uiOutput("new_game_ui")
  #   )
  # ),
  fluidRow(
    div(class = "col-md",
      uiOutput("keyboard")
    )
  ),
  tags$script(HTML("
    const letters = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',
                     'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];
    const all_key_ids = [ ...letters, 'Enter', 'Space', 'Back'];
    document.addEventListener('keydown', function(e) {
      let key = e.code.replace(/^Key/, '');
      if (letters.includes(key)) {
        document.getElementById(key).click();
      } else if (key == 'Space') {
        document.getElementById('Space').click();
      } else if (key == 'Enter') {
        document.getElementById('Enter').click();
      } else if (key == 'Backspace') {
        document.getElementById('Back').click();
      }
    });

    // For better responsiveness on touch devices, trigger a click on the button
    // when a touchstart event occurs; don't wait for the touchend event. So
    // that a click event doesn't happen when the touchend event happens (and
    // cause the letter to be typed a second time), we set the 'pointer-events'
    // CSS property to 'none' on the button. Then when there's _any_ touchend
    // event, unset the 'pointer-events' CSS property on all of the buttons, so
    // that the button can be touched again.
    let in_button_touch = false;
    document.addEventListener('touchstart', function(e) {
        if (all_key_ids.includes(e.target.id)) {
            e.target.click();
            e.target.style.pointerEvents = 'none';
            e.preventDefault();   // Disable text selection
            in_button_touch = true;
        }
    });
    document.addEventListener('touchend', function(e) {
        all_key_ids.map((id) => {
            document.getElementById(id).style.pointerEvents = null;
        });
        if (in_button_touch) {
            if (all_key_ids.includes(e.target.id)) {
                // Disable text selection and triggering of click event.
                e.preventDefault();
            }
            in_button_touch = false;
        }
    });
  "))
)


server <- function(input, output) {

  # Set the random seed based on the date, so that the same word is used during
  # each day.
  #set.seed(as.integer(Sys.Date()))

  target_geo <- reactiveVal(sample(all_geos$geo_name_std, 1))
  all_guesses <- reactiveVal(list())
  finished <- reactiveVal(FALSE)
  win_moves <- reactiveVal(0)
  current_guess_letters <- reactiveVal(character(0))
  invalid_geo_message <- reactiveVal("")
  loser <- reactiveVal(FALSE)

  output$geo_map <- renderPlot({
    message(toupper(target_geo()))
    map_df <- filter(all_geos, geo_name_std == target_geo())

    # Inital map: muni boundaries only
    p <- ggplot(map_df) +
      geom_sf(fill = "#008fd5", col = NA) +
      theme_void()

    print(p)
  })

  # output$final_map <- renderPlot({
  #   if (!finished()) return()
  #   map_df <- filter(all_geos, geo_name_std == target_geo())
  #
  #   # Final map: add county boundaries for context
  #   p <- ggplot(map_df) +
  #     geom_sf(fill = "#008fd5", col = "#008fd5", lwd = 1) +
  #     geom_sf(data = filter(county_sf, cmap), fill = NA, col = "#2d4147", lwd = 1) +
  #     labs(title = toupper(target_geo())) +
  #     theme_void() +
  #     theme(plot.title = element_text(face = "bold", size = 20, hjust = 0.5, color = "#008fd5"))
  #
  #   print(p)
  # })


  observeEvent(input$Enter, {
    guess <- tolower(paste(current_guess_letters(), collapse = ""))
    message(guess)

    if (! guess %in% all_geos$geo_name_std) {
      invalid_geo_message(paste0('"', toupper(guess), '" is not a municipality in Northeastern Illinois'))
      #current_guess_letters(character(0))  # Clears invalid guess. If not used, user has to backspace and correct.
      return()  # Don't process the guess any further
    } else {
      invalid_geo_message("")
    }

    #message(dist_to_target(guess))
    #message(dir_to_target(guess))

    all_guesses_new <- all_guesses()

    check_result <- check_word(guess, target_geo())
    all_guesses_new[[length(all_guesses_new) + 1]] <- check_result
    all_guesses(all_guesses_new)
    message(length(all_guesses()))

    if (isTRUE(check_result$win)) {
      finished(TRUE)
      win_moves(length(all_guesses()))
      message(paste("Won in", win_moves()))
    } else if (length(all_guesses()) == 6) {
      finished(TRUE)
      loser(TRUE)  # :(
    }

    current_guess_letters(character(0))
  })

  output$previous_guesses <- renderUI({
    res <- lapply(all_guesses(), function(guess) {
      letters <- guess$letters
      row <- mapply(
        letters,
        guess$matches,
        FUN = function(letter, match) {
          # This will have the value "correct", "in-word", or "not-in-word", and
          # those values are also used as CSS class names.
          match_type <- match
          div(toupper(letter), class = paste("letter", match_type))
        },
        SIMPLIFY = FALSE,
        USE.NAMES = FALSE
      )
      div(class = "word", row, guess$distance_away, guess$bearing)
    })

    scroll_js <- "
        document.querySelector('.guesses')
          .scrollTo(0, document.querySelector('.guesses').scrollHeight);
    "
    tagList(res, tags$script(HTML(scroll_js)))
  })

  output$current_guess <- renderUI({
    if (finished()) return()

    letters <- current_guess_letters()

    div(class = "word",
        lapply(letters, function(letter) {
          div(toupper(letter), class="letter guess")
        }),
        div(invalid_geo_message(), id="invalid-guess"))
  })

  # output$new_game_ui <- renderUI({
  #   if (!finished())
  #     return()
  #
  #   actionButton("new_game", "New Game")
  # })
  #
  # observeEvent(input$new_game, {
  #   reset_game()
  # })

  used_letters <- reactive({
    # This is a named list. The structure will be something like:
    # list(p = "not-in-word", a = "in-word", e = "correct")
    letter_matches <- list()

    # Populate `letter_matches` by iterating over all letters in all the guesses.
    lapply(all_guesses(), function(guess) {
      mapply(guess$letters, guess$matches, SIMPLIFY = FALSE, USE.NAMES = FALSE,
             FUN = function(letter, match) {
               prev_match <- letter_matches[[letter]]
               if (is.null(prev_match)) {
                 # If there isn't an existing entry for that letter, just use it.
                 letter_matches[[letter]] <<- match
               } else {
                 # If an entry is already present, it can be "upgraded":
                 # "not-in-word" < "in-word" < "correct"
                 if (match == "correct" && prev_match %in% c("not-in-word", "in-word")) {
                   letter_matches[[letter]] <<- match
                 } else if (match == "in-word" && prev_match == "not-in-word") {
                   letter_matches[[letter]] <<- match
                 }
               }
             }
      )
    })

    letter_matches
  })


  keys <- list(
    c("Q", "W", "E", "R", "T", "Y", "U", "I", "O", "P"),
    c("A", "S", "D", "F", "G", "H", "J", "K", "L"),
    c("Z", "X", "C", "V", "B", "N", "M"),
    c("Enter", "Space", "Back")
  )

  output$keyboard <- renderUI({
    prev_match_type <- used_letters()
    keyboard <- lapply(keys, function(row) {
      row_keys <- lapply(row, function(key) {
        class <- "key"
        key_lower <- ifelse(key == "Space", " ", tolower(key))
        if (!is.null(prev_match_type[[key_lower]])) {
          class <- c(class, prev_match_type[[key_lower]])
        }
        if (key %in% c("Enter", "Space", "Back")) {
          class <- c(class, "wide-key")
        }
        actionButton(key, key, class = class)
      })
      div(class = "keyboard-row", row_keys)
    })

    if (!finished()) {
      div(class = "keyboard", keyboard)
    } else {
      return()  # Hide keyboard once game is done
    }
  })

  # Add listeners for each key, except Enter and Back
  lapply(unlist(keys, recursive = FALSE), function(key) {
    if (key %in% c("Enter", "Back")) return()
    observeEvent(input[[key]], {
      if (finished())
        return()
      cur <- current_guess_letters()
      if (key == "Space") {
        current_guess_letters(c(cur, " "))
      } else {
        current_guess_letters(c(cur, tolower(key)))
      }
    })
  })

  observeEvent(input$Back, {
    if (length(current_guess_letters()) > 0) {
      current_guess_letters(current_guess_letters()[-length(current_guess_letters())])
    }
  })


  output$loser_message <- renderUI({
    if (!loser()) {
      return()
    } else {
      div(class = "loser", paste0('The correct answer was "', toupper(target_geo()), '"'))
    }
  })


  output$cds_link <- renderUI({
    if (!finished()) {
      return()
    } else {
      cds_url = paste0("https://www.cmap.illinois.gov/documents/10180/102881/",
                       str_replace_all(target_geo(), " ", "+"),
                       ".pdf")
      if (target_geo() == "st charles") {
        cds_url <- str_replace(cds_url, "st+charles", "st.+charles")
      }
      div(id = "cds-link",
        "View the ", a("Community Data Snapshot", href=cds_url)
      )
    }
  })


  output$endgame <- renderUI({
    if (!finished())
      return()

    lines <- lapply(all_guesses(), function(guess) {
      line <- vapply(guess$matches, function(match) {
        switch(match,
               "correct" = "ðŸŸ©",
               "in-word" = "ðŸŸ¨",
               "not-in-word" = "â¬œ"
        )
      }, character(1))

      div(paste(line, collapse = ""))
    })
    message(lines)

    div(class = "endgame-content",
      if (win_moves() > 0) {
        div(paste0(THE_NAME, " ", win_moves(), "/6 ðŸŽ‰"))
      } else {
        div(paste0(THE_NAME, " X/6 ðŸ˜”"))
      },
      lines,
      div(THE_URL)
    )
  })

  check_word <- function(guess_str, target_str) {
    guess_str <- tolower(guess_str)
    guess <- strsplit(guess_str, "")[[1]]
    target <- strsplit(target_str, "")[[1]]
    remaining <- target

    result <- rep("not-in-word", length(guess))

    # First pass: find matches in correct position. Letters in the target that do
    # not match the guess are added to the remaining list.
    for (i in seq_along(guess)) {
      if (i <= length(target)) {
        if (guess[i] == target[i]) {
          result[i] <- "correct"
          remaining <- remaining[-match(guess[i], remaining)]
        }
      }
      #message(1, " ", guess[i], " ", remaining, " ", result)
    }

    for (i in seq_along(guess)) {
      if ((i > length(target) || guess[i] != target[i]) && guess[i] %in% remaining) {
        result[i] <- "in-word"
        remaining <- remaining[-match(guess[i], remaining)]
      }
      #message(2, " ", guess[i], " ", remaining, " ", result)
    }

    list(
      word = guess_str,
      letters = guess,
      matches = result,
      win = guess_str == target_str,
      distance_away = dist_to_target(guess_str),
      bearing = dir_to_target(guess_str)
    )
  }

  dist_to_target <- function(guess) {
    if (is.null(guess)) return()
    distance_ft <- geo_distances[all_geos$geo_name_std == guess,
                                 all_geos$geo_name_std == target_geo()]
    return(paste0(round(distance_ft / 5280, 1), " mi."))
  }

  dir_to_target <- function(guess) {
    if (is.null(guess)) return()
    guess_xy <- filter(all_geos, geo_name_std == guess)$centroid[[1]]
    target_xy <- filter(all_geos, geo_name_std == target_geo())$centroid[[1]]
    if (guess_xy == target_xy) return("ðŸŽ¯")
    angle <- atan2(target_xy[2] - guess_xy[2], target_xy[1] - guess_xy[1]) * 180 / pi
    index <- round(floor(((angle + 22.5) %% 360) / 45)) + 1
    cardinal_dirs <- c("âž¡", "â†—", "â¬†", "â†–", "â¬…", "â†™", "â¬‡", "â†˜")  # Order here is critical
    # cardinal_dirs <- c("E", "NE", "N", "NW", "W", "SW", "S", "SE")  # Order here is critical
    bearing <- cardinal_dirs[index]
    return(bearing)
  }

  # reset_game <- function() {
  #   target_geo(sample(all_geos$geo_name_std, 1))
  #   all_guesses(list())
  #   finished(FALSE)
  # }

}

shinyApp(ui, server)
